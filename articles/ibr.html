<!DOCTYPE html>
<html lang="en" >
<head>
  <meta charset="UTF-8">
  <title>x64mayhem | Instruction Rewriting.</title>
  <link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/meyer-reset/2.0/reset.min.css">
<link rel="stylesheet" href="./style.css">

</head>
<body>
<!-- partial:index.partial.html -->
<head>
  <link href='https://fonts.googleapis.com/css?family=Source+Sans+Pro' rel='stylesheet' type='text/css'>

  <script type="text/javascript" src="//ajax.googleapis.com/ajax/libs/jquery/1.10.2/jquery.min.js"></script>
</head>

<header>
<h1>Introduction to Instruction Rewriting and Binary patching</h1>
</header>
  
<section class="container">
  <p><strong>Baby steps to binary patching</strong></p>
<h3>Background story
</h3>
<p>
  “Almost every code we write and compile is converted into machine code and set of instructions.”

Pretty basic definition for what compiler does huh?

Well, let me re-frame that with respect to a reverse engineer’s point of view,

</p>
<p>“It doesn’t matter if you write your code in C, C++ or C# it will be converted into machine code, which can be viewed as a common low level language, Assembly.”

  In simpler terms, all we need to understand is the assembly of code and without having its actual source code we can conclude what it will do. Now what to do from here?
  Imagine we got a program that will activate when provided with valid key, pretty common scenario right? You might say just buy the key, or download the crack etc. pretty boring solutions too… Now, what if I tell you, we can activate the program just by changing it’s binary, that too just 2–6 bytes! YES! And that’s what we will try to understand in this article.
  
  Actually most of such programs use comparison statements to check if your key matches with the actual key or not, e.g. “if (input == key) {//do thing here}” etc.</p>

<p>And that very thing in assembly is done by “CMP” instruction and then followed by a “JMP” or similar instruction to shift the flow of controls according to the result of comparison.
Let’s do it.

Let us make an application, this application works in the same fashion, check for the key and activate if matches. The program is written in C and compiled by the GCC compiler.</p>


<h3>Let's do it.</h3>
<p>Let us make an application, this application works in the same fashion, check for the key and activate if matches. The program is written in C and compiled by the GCC compiler.</p>

<script src="https://gist.github.com/Saket-Upadhyay/de00ca18c58b7240df45267f10a467b0.js"></script>
<p>Here is one example where we use <strong>“saket”</strong> as the key.</p>

<img src="https://miro.medium.com/max/761/1*K_G78S10NaB8cpo5rCagRg.png">

<p>When we observe the compiled binary in our favorite debugger we can see one instruction <strong>“CMP [RBP+VAR_18], 394H”</strong> that checks the string passed and then compares it with (394)h =(916)d that seems to be string length or something, the interesting part is that it is followed by “<strong>JNZ SHORT LOC_400657</strong>” instruction, which makes EIP or instruction pointer to point at <strong>400657th</strong> location. In simple words, shifts the control flow to 400657th location in memory , and execute instruction from there. Further we can see that <strong>LOC_400657</strong> contains instructions of WRONG KEY part of software.</p>
<img src="https://miro.medium.com/max/959/1*QiRX5E9kSXkvrN7YyTFedg.png">

<p>So what if we can just skip that jump statement and whatever the result of the <strong>CMP</strong> we will just continue to Access Granted part. To do that we will just change jump address in HEX DUMP from <strong>“0C” to “00”</strong>
   which will cause EIP to just continue to the next instruction.
<br>
  For that we will go to the hex equivalent of the instruction in dump and change the value in target address.</p>
  <img src="https://miro.medium.com/max/701/1*Ndw-9qh6-jx-Pw79bJhUiQ.png">
  <p>here we can observe JNZ instruction starts at 400649 (relative address), we can go to same in hex dump to get equivalent hex values.</p>
<img src="https://miro.medium.com/max/689/1*uxriK_ycJjHxt-aYJYJ-3w.png">
<p>now we know that <strong>JNZ SHORT LOC_400649 ~ 750C</strong>; Now keeping JNZ intact, i.e. not changing 75, we can change 0C to 00 to try to null it’s effect. or we can just replace the next effective address,something like this :</p>
<img src="https://miro.medium.com/max/521/1*OLDef_3bUFDIOlGgpSA3rg.png">
<p>BUT FOR THIS ARTICLE we will just replace 0C with 00…</p>
FROM -> <img src="https://miro.medium.com/max/121/1*9xX5CM7-5zkwUw-jLW_vsg.png"> TO -> <img src="https://miro.medium.com/max/91/1*dUlh5aSmPdg0vdDGWOzXnw.png">
<P>And now you can see our instruction continues to ACCESS GRANTED part, and no instruction points to WRONG KEY. That means we should be able to activate the software with any key we want!.</P>
<img src="https://miro.medium.com/max/760/1*BVYRUDW4dLcBwd2jCT16HQ.png">
<p>Now let’s check that with the same key we provided, and just another key to check our modification.</p>
<img src="https://miro.medium.com/max/938/1*-In-V9fwv_pAMbyqhCYTJg.png">
<br>
<h3>Conclusion</h3>
<p>Binary rewriting in real-world scenarios is much more complex than this example, but anyways this is just introduction with the aim to get the reader familiar with the concept.
<br>
  I hope you enjoyed this article, have a super productive day ahead !</p>








<p><a href="">--Back to Home </a></p>
</section>
<!-- partial -->
  <script  src="./script.js"></script>
<br>
</body>
</html>
